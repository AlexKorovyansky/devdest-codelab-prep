# Кодлаб - умное офисное кресло

В рамках codelab мы создадим умное офисное кресло, которое поможет вам во время делать перерывы и вставать разминаться. Нас ждет увлекательная командная работа – соединение электронных компонентов, программирование микроконтроллера, подключение/настройка Firebase и разработка Web приложения для отображения собираемой информации. Пройдя codelab вы научитесь основам программирования Arduino микроконтроллеров и поймете как использовать связку Arduino+Firebase для быстрого прототипирования IoT решений.

## Постановка задачи

Мы хотим, чтобы наше умное офисное кресло отображало "состояние здоровья" с помощью индикатора подобного уровню заряда батарейки в телефоне. Когда мы сидим на кресле "уровень здоровья" должен уменьшаться, разряжаясь полностью за 25 минут. Если мы встали с кресла, то "здоровье" должно увеличиваться, заряжаясь полностью за 5 минут.

<описать какое железо нам понадобиться и в какие шаги мы будем собирать кресло>

## Шаг 0. Подготовка к работе

Для работы c WioLink нам потребуется установить драйвер - http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx 

В качестве среды разработки мы будем использовать PlatformIO - http://platformio.org/get-started. Это кроссплатформенная IDE на базе текстового редактора Atom, позволяющая программировать под большое количество микроконтроллеров. 

После установки и запуска Platform IO IDE необходимо создать новый проект (Меню: Platform IO > Initialize or Update PlatformIO Project). В диалоге создания проекта необходиму указать тип платы микроконтроллера и путь по которому будет размещаться наш проект. WioLink основана на процессоре esp8266, поэтому среди предложенного перечня плат нам подойдет Espressif ESP8266 ESP-12E. После нажатия кнопки Process, Platform IO скачает все необходимые файлы для работы с нашим микропроцессором.

Помимо служебных файлов во вновь созданном проекте будет содержаться папки lib и src. Папка lib является хранилищем библиотек, подключенных к этому проекту, а папка src предназначена для кода проекта. Точками входа приложения выступают функция void setup - для разового запуска настроек и функция void loop - для зацикленного запуска необходимой логики. Компилятор ищет эти функции во всех файлах в директории src. 

Например, мы можем создать файл main.cpp в папке src, подключить библиотеку Arduino.h и объявить функции setup и loop следующим образом:

```
#include <Arduino.h>

void setup() {
	// инициализация Serial порта c baudrate равным 28800
  Serial.begin(28800)
  
  // Для включения GPIO портов на плате WioLink необходимо подать высокий сигнал на 15-ый пин микропроцессора.
	pinMode(15, OUTPUT);
	digitalWrite(15, HIGH);
}


void loop() {
  Serial.println("Hello World! Devfest Siberia 2016 rulezzzz");
  delay(1000);
}

```

Для того, чтобы запустить данную программу на микроконтроллере нужно подключить его к компьютеру с помощью кабеля USB-microUSB и залить прошивку на контроллер (с помощью кнопки в виде стрелочке в toolbar слева или из меню Platform IO - Upload).

Для отображения информации с последовательного порта в Platform IO необходимо включить монитор последовательного порта из меню (Platform IO - Serial Monitor), указав baudrate (в нашем случае 28800) и соответствующий порт (типа CP2102 USB to UART Bridge controller).

**Задача:** Реализовать схему, выводящую на консоль “Devfest Siberia 2016 rulezzzz” ~ раз в 1000 миллисекунд. Если вы справились с этой задачей значит вы корректно настроили окружение и готовы двигаться вперед к реализации нашего умного кресла!

**Заметка 1:** Периодически при работе с WioLink после прошивки плата “зависает”. В этом случае помогает нажатие кнопки reset, расположенной на WioLink. Если ваша программа делает вид, что работает, но ничего не выводит на консоль значит плата зависла и вам нужно нажать кнопку reset.

**Заметка 2:** Вы узнали старый добрый синтаксис? Да, наша программа написана на C++. При этом в Arduino сообществе нет четко определенного code style и каждый пишет как умеет. Вы еще успеете посетовать на это подключая сторонние библиотеки в Шаге 1. А пока настройтесь писать несовершенный код, это же кодлаб, рефакторить будете потом, а сейчас будем творить!

## Шаг 1 - Сборка железа

На WioLink размещены 6 Grove совместимых разъемов. Из них 3 цифровых (Digital), 1 аналоговый (Analog), 1 UART и 1 I2C. Рядом с разъемами подписаны пины контроллера, подключенные к этим разъемам, а также пины к которым подключены 3.3 вольта и земля. К разъемам подключаются датчики и исполнительные механизмы.

Для отображения "уровня здоровья" мы будем использовать [Grove Led Bar](https://www.seeedstudio.com/Grove-LED-Bar-v2.0-p-2474.html). Этот элемент имеет четыре пина: два сигнальных пина (dcki и di), пин для подключения питания (3.3 - 5 В) и пин для подключения земли. Как и любой другой grove совместимый элемент, наш Led Bar легко и надежно подключается к плате с помощью grove кабеля. Если вы воткнете Led в разъем Digital 1, то dcki займет 13 пин контроллера, а di займет 12-ый. 

Для взаимодействия с Led Bar рекомендуем использовать подключаемую библиотеку https://github.com/Seeed-Studio/Grove_LED_Bar. Нужно скачать репозиторий библиотеки, распаковать архив и полученную папку перенести в папку lib нашего проекта. 

Подключение библиотеки осуществляется с помощью #include <Grove_LED_Bar.h> и позволяет создавать объекты Grove_LED_Bar с помощью конструктора Grove_LED_Bar(pinDcki, pinDi, direction), где pinDclk, pinDi - номера соответствующих сигнальных пинов, direction - направление загорания диодов (0 - прямое, 1 - обратное). Для инициализации полученного объекта необходимо вызвать метод объекта begin() в функции setup. Для управления LED Bar-ом рекомендуем использовать метод setLevel (float level), значение level может варьироваться от 0 до 10, включая дробные значения. В зависимости от выбранного level будет включаться соответственное количество диодов (от 0 до 10). В случае если указано дробное число, будет меняться яркость свечения последнего диода. 

**Задача:** Реализовать схему, которая на старте зажигает все десять индикаторов LED Bar-а и дальше постепенно гасит все индикаторы (10, 9, 8 ... 0). Если вам захочется перезапустить программу вы можете воспользоваться кнопкой reset.

Для определения сидит пользователь на стуле или нет предлагается использовать ультразвуковой дальномер Grove Ultrasonic. Этот датчик имеет один цифровой сигнальный пин, пин для подключения питания (3.3 - 5 В) и пин земли, четвертый пин Groove разъема не используется. 

Для работы с Ultrasonic датчиком рекомендуется скачать библиотеку https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger и подключить ее к проекту. 
Для этого необходимо скачать библиотеку и разместить подключаемую библиотеку в папке lib, и использовать команду вида #include <Ultrasonic.h>. Platform IO автоматически находит все библиотеки в папке lib и добавляет необходимые пути на этапе конфигурации препроцессора. После добавления библиотеки к репозиторию и ее подключения, появится возможность создавать объекты класс Ultrasonic с помощью конструктора Ultrasonic(pinUltrasonicRangeFinder). Измеряемой расстояние можно узнать с помощью метода MeasureInCentimeters() созданного объекта.

Для отображения уровня напряжения возможно использовать Grove Led bar. Этот элемент имеет два сигнальных пина (dcki и di) и два пина для подключения питания (3.3 - 5 В) и земли. Рекомендуемая библиотека для работы с ним https://github.com/Seeed-Studio/Grove_LED_Bar. Она подключается с помощью #include <Grove_LED_Bar.h> и позволяет создавать объекты Grove_LED_Bar с помощью конструктора Grove_LED_Bar(pinDcki, pinDi, direction). Где pinDclk, pinDi - номера соответствующих сигнальных пинов, direction - направление загорания диодов (0 - прямое, 1 - обратное). Для инициализации полученного объекта необходимо вызвать метод объекта begin() в функции setup. Управление Led bar происходит с помощью метода setLevel (float level) созданного объекта, при этом level может варьироваться от 0 до 10, включая дробные значения. В зависимости от значения level будет включаться соответственное количество диодов (от 0 до 10). В случае если указано дробное число, будет меняться яркость свечения последнего диода. 


Задача: ввести параметры задающие длительность между отдыхами (sittingDurationInSec), длительность отдыха (restorationDurationInSec) и текущую “‘энергию” (energy). Энергия должна иметь фиксированный верхний предел и расходоваться пока пользователь сидит на стуле и восстанавливаться пока он не сидит. Полностью энергия должна расходоваться за время sittingDurationInSec, восстанавливаться за время restorationDurationInSec. Энергия должна в режиме реального времени пропорционально отображаться на Led Barе, а ее значение передаваться по последовательному порту.

## Шаг 2 - Подключение к WiFi и Firebase

Для использования WiFi с помощью чипа esp8266, в проект необходимо добавить библиотеку ESP8266WiFi. Эта библиотека загрузилась Platform IO вместе с инструментарием для разработки под esp8266. Она является глобальной, то есть нет необходимости ее добавлять в каждый проект. Достаточно использовать #include <ESP8266WiFi.h>.


WiFi инициализируется с помощью статического метода WiFi.begin(WIFI_SSID, WIFI_PASSWORD), его статус можно проверить с помощью проверки WiFi.status() == WL_CONNECTED. В случае истинности выражения можно продолжать выполнение программы дальше.


В качестве backendа для DIY IoT удобно использовать Firebase базу данных. Для этого достаточно создать новый проект - https://firebase.google.com/ и получить секрет-ключ для доступа. Ключ для доступа к базе данных можно получить в настройках проекта (шестеренка рядом с названием проекта - настройки проекта - сервисные аккаунты - секреты базы данных). Также понадобиться URL для авторизации. Его можно посмотреть на странице Firebase Admin SDK (шестеренка рядом с названием проекта - настройки проекта - сервисные аккаунты - Firebase Admin SDK - databaseURL
в предлагаемой для Node.js конфигурации) он выглядит как my-awesome-project.firebaseio.com (без https://).


Firebase предоставляет облачную NoSQL БД для real-time приложений. Она хранит информацию в JSON формате и для считывания\записи информации необходимо указывать полный путь для объекта.


Для использования Firebase базы данных в WioLink удобно использовать библиотеку https://github.com/googlesamples/firebase-arduino. И подключить с помощью #include <FirebaseArduino.h>. При сборке проекта с этой библиотекой компилятор будет ругаться на отсутствие файла  ESP8266HTTPClien.h. Причина в том, что Platform IO добавляет на этапе прекомпиляции только те библиотеки на которые есть прямые ссылки из файлов из папки src. Поэтому достаточно добавить строчку #include <ESP8266HTTPClien.h> до подключения библиотеки FirebaseArduino
Инициализирование Firebase происходит с помощью вызова статического метода Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH). После чего возможно использовать методы для сохранения в базу данных значений. К примеру метод Firebase.setInt("path/to/variable_name", variable_value) используется для сохранения int переменной с именем variable_name и значением variable_value в базу данных по пути path/to/. А также методы получения данных, к примеру Firebase.getInt("path/to/variable_name") для получения значения int переменной variable_name, находящейся в базе данных по пути path/to/. 


Задача: создать новый Firebase проект. В базе данных проекта создать две переменные, отвечающие за длительность между отдыхами (sittingDuration) и длительность отдыха (restorationDuration). Раз в двадцать секунд запрашивать значение этих переменных и использовать их для расчета энергии пользователя. Раз в фиксированный интервал времени сохранять в Firebase информацию о текущем уровне энергии.


Заметка 1: Если последний вызванный Firebase метод завершился с ошибкой, метод Firebase.failed() - вернет true, в противном случае ложь. String переменную с описание ошибки можно получить вызовом метода Firebase.error().


Заметка 2: В предложенном решение необходимо добавить данные о Firebase и WiFi в файл Config.h.
