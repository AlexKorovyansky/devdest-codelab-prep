# Кодлаб - умное офисное кресло

В рамках codelab мы создадим умное офисное кресло, которое поможет вам во время делать перерывы и вставать разминаться. Нас ждет увлекательная командная работа – соединение электронных компонентов, программирование микроконтроллера, подключение/настройка Firebase и разработка Web приложения для отображения собираемой информации. Пройдя codelab вы научитесь основам программирования Arduino микроконтроллеров и поймете как использовать связку Arduino+Firebase для быстрого прототипирования IoT решений.

## Постановка задачи

Мы хотим, чтобы наше умное офисное кресло отображало состояние здоровья с помощью индикатора подобного уровню заряда батарейки в телефоне. Когда мы сидим на кресле уровень здоровья должен уменьшаться, разряжаясь полностью за 25 минут. Если мы встали с кресла, то здоровье должно увеличиваться, заряжаясь полностью за 5 минут.

<описать какое железо нам понадобиться и в какие шаги мы будем собирать кресло>

## Шаг 0. Подготовка к работе

Для работы c WioLink нам потребуется установить драйвер - http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx 

В качестве среды разработки мы будем использовать PlatformIO - http://platformio.org/get-started. Это кроссплатформенная IDE на базе текстового редактора Atom, позволяющая программировать под большое количество микроконтроллеров. 

После установки и запуска Platform IO IDE необходимо создать новый проект (Меню: Platform IO > Initialize or Update PlatformIO Project). В диалоге создания проекта необходиму указать тип платы микроконтроллера и путь по которому будет размещаться наш проект. WioLink основана на процессоре esp8266, поэтому среди предложенного перечня плат нам подойдет Espressif ESP8266 ESP-12E. После нажатия кнопки Process, Platform IO скачает все необходимые файлы для работы с нашим микропроцессором.

Помимо служебных файлов во вновь созданном проекте будет содержаться папки lib и src. Папка lib является хранилищем библиотек, подключенных к этому проекту, а папка src предназначена для кода проекта. Точками входа приложения выступают функция void setup - для разового запуска настроек и функция void loop - для зацикленного запуска необходимой логики. Компилятор ищет эти функции во всех файлах в директории src. 

Например, мы можем создать файл main.cpp в папке src, подключить библиотеку Arduino.h и объявить функции setup и loop следующим образом:

```
#include <Arduino.h>

void setup() {
	// инициализация Serial порта c baudrate равным 28800
  Serial.begin(28800)
  
  // Для включения GPIO портов на плате WioLink необходимо подать высокий сигнал на 15-ый пин микропроцессора.
	pinMode(15, OUTPUT);
	digitalWrite(15, HIGH);
}


void loop() {
  Serial.println("Hello World! Devfest Siberia 2016 rulezzzz");
  delay(1000);
}

```

Для того, чтобы запустить данную программу на микроконтроллере нужно подключить его к компьютеру с помощью кабеля USB-microUSB и залить прошивку на контроллер (с помощью кнопки в виде стрелочке в toolbar слева или из меню Platform IO - Upload).

Для отображения информации с последовательного порта в Platform IO необходимо включить монитор последовательного порта из меню (Platform IO - Serial Monitor), указав baudrate (в нашем случае 28800) и соответствующий порт (типа CP2102 USB to UART Bridge controller).

**Задача:** Реализовать программу выводящую на консоль “Devfest Siberia 2016 rulezzzz” ~ раз в 1000 миллисекунд. Если вы справились с этой задачей значит вы корректно настроили окружение и готовы двигаться вперед к реализации нашего умного кресла!

**Заметка 1:** Периодически при работе с WioLink после прошивки плата “зависает”. В этом случае помогает нажатие кнопки reset, расположенной на WioLink. Если ваша программа делает вид, что работает, но ничего не выводит на консоль значит плата зависла и вам нужно нажать кнопку reset.

**Заметка 2:** Вы узнали старый добрый синтаксис? Да, наша программа написана на C++. При этом в Arduino сообществе нет четко определенного code style и каждый пишет как умеет. Вы еще успеете посетовать на это подключая сторонние библиотеки в Шаге 1. А пока настройтесь писать несовершенный код, это же кодлаб, рефакторить будете потом, а сейчас будем творить!

## Шаг 1 - Сборка железа

На WioLink размещены 6 Grove совместимых разъемов. Из них 3 цифровых (Digital), 1 аналоговый (Analog), 1 UART и 1 I2C. Рядом с разъемами подписаны пины контроллера, подключенные к этим разъемам, а также пины к которым подключены 3.3 вольта и земля. К разъемам подключаются датчики и исполнительные механизмы.

Для определения сидит пользователь на стуле или нет предлагается использовать ультразвуковой дальномер Grove Ultrasonic. Этот датчик имеет один цифровой сигнальный пин, пин для подключения питания (3.3 - 5 В) и пин земли, четвертый пин Groove разъема не используется. 

Для работы с Ultrasonic датчиком рекомендуется скачать библиотеку https://github.com/Seeed-Studio/Grove_Ultrasonic_Ranger и подключить ее к проекту. 
Для этого необходимо скачать библиотеку и разместить подключаемую библиотеку в папке lib, и использовать команду вида #include <Ultrasonic.h>. Platform IO автоматически находит все библиотеки в папке lib и добавляет необходимые пути на этапе конфигурации препроцессора. После добавления библиотеки к репозиторию и ее подключения, появится возможность создавать объекты класс Ultrasonic с помощью конструктора Ultrasonic(pinUltrasonicRangeFinder). Измеряемой расстояние можно узнать с помощью метода MeasureInCentimeters() созданного объекта.

Для отображения уровня напряжения возможно использовать Grove Led bar. Этот элемент имеет два сигнальных пина (dcki и di) и два пина для подключения питания (3.3 - 5 В) и земли. Рекомендуемая библиотека для работы с ним https://github.com/Seeed-Studio/Grove_LED_Bar. Она подключается с помощью #include <Grove_LED_Bar.h> и позволяет создавать объекты Grove_LED_Bar с помощью конструктора Grove_LED_Bar(pinDcki, pinDi, direction). Где pinDclk, pinDi - номера соответствующих сигнальных пинов, direction - направление загорания диодов (0 - прямое, 1 - обратное). Для инициализации полученного объекта необходимо вызвать метод объекта begin() в функции setup. Управление Led bar происходит с помощью метода setLevel (float level) созданного объекта, при этом level может варьироваться от 0 до 10, включая дробные значения. В зависимости от значения level будет включаться соответственное количество диодов (от 0 до 10). В случае если указано дробное число, будет меняться яркость свечения последнего диода. 


Задача: ввести параметры задающие длительность между отдыхами (sittingDurationInSec), длительность отдыха (restorationDurationInSec) и текущую “‘энергию” (energy). Энергия должна иметь фиксированный верхний предел и расходоваться пока пользователь сидит на стуле и восстанавливаться пока он не сидит. Полностью энергия должна расходоваться за время sittingDurationInSec, восстанавливаться за время restorationDurationInSec. Энергия должна в режиме реального времени пропорционально отображаться на Led Barе, а ее значение передаваться по последовательному порту.


Заметка 1: Функции Arduino библиотеке bitSet() и bitClear() позволяют устанавливать в 1 или 0 указанный бит для переданного числа. Они принимают два аргумента первый - число в котором необходимо изменить бит, второй - номер изменяемого бита. Это упрощает работу с Led barом.


Stage 2 - WiFi and Firebase


Для использования WiFi с помощью чипа esp8266, в проект необходимо добавить библиотеку ESP8266WiFi. Эта библиотека загрузилась Platform IO вместе с инструментарием для разработки под esp8266. Она является глобальной, то есть нет необходимости ее добавлять в каждый проект. Достаточно использовать #include <ESP8266WiFi.h>.


WiFi инициализируется с помощью статического метода WiFi.begin(WIFI_SSID, WIFI_PASSWORD), его статус можно проверить с помощью проверки WiFi.status() == WL_CONNECTED. В случае истинности выражения можно продолжать выполнение программы дальше.


В качестве backendа для DIY IoT удобно использовать Firebase базу данных. Для этого достаточно создать новый проект - https://firebase.google.com/ и получить секрет-ключ для доступа. Ключ для доступа к базе данных можно получить в настройках проекта (шестеренка рядом с названием проекта - настройки проекта - сервисные аккаунты - секреты базы данных). Также понадобиться URL для авторизации. Его можно посмотреть на странице Firebase Admin SDK (шестеренка рядом с названием проекта - настройки проекта - сервисные аккаунты - Firebase Admin SDK - databaseURL
в предлагаемой для Node.js конфигурации) он выглядит как my-awesome-project.firebaseio.com (без https://).


Firebase предоставляет облачную NoSQL БД для real-time приложений. Она хранит информацию в JSON формате и для считывания\записи информации необходимо указывать полный путь для объекта.


Для использования Firebase базы данных в WioLink удобно использовать библиотеку https://github.com/googlesamples/firebase-arduino. И подключить с помощью #include <FirebaseArduino.h>. При сборке проекта с этой библиотекой компилятор будет ругаться на отсутствие файла  ESP8266HTTPClien.h. Причина в том, что Platform IO добавляет на этапе прекомпиляции только те библиотеки на которые есть прямые ссылки из файлов из папки src. Поэтому достаточно добавить строчку #include <ESP8266HTTPClien.h> до подключения библиотеки FirebaseArduino
Инициализирование Firebase происходит с помощью вызова статического метода Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH). После чего возможно использовать методы для сохранения в базу данных значений. К примеру метод Firebase.setInt("path/to/variable_name", variable_value) используется для сохранения int переменной с именем variable_name и значением variable_value в базу данных по пути path/to/. А также методы получения данных, к примеру Firebase.getInt("path/to/variable_name") для получения значения int переменной variable_name, находящейся в базе данных по пути path/to/. 


Задача: создать новый Firebase проект. В базе данных проекта создать две переменные, отвечающие за длительность между отдыхами (sittingDuration) и длительность отдыха (restorationDuration). Раз в двадцать секунд запрашивать значение этих переменных и использовать их для расчета энергии пользователя. Раз в фиксированный интервал времени сохранять в Firebase информацию о текущем уровне энергии.


Заметка 1: Если последний вызванный Firebase метод завершился с ошибкой, метод Firebase.failed() - вернет true, в противном случае ложь. String переменную с описание ошибки можно получить вызовом метода Firebase.error().


Заметка 2: В предложенном решение необходимо добавить данные о Firebase и WiFi в файл Config.h.
